# -*- coding: utf-8 -*-
"""Clean_Informed.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OLOr-J_oGXAAA_wGUnnmJ8AyTBDvQj-1
"""

import os
import sys
import math
import random
import numpy as np
import matplotlib.pyplot as plt
from scipy.spatial.transform import Rotation as Rot
import matplotlib.patches as patches
from scipy import interpolate
from Availibity_checker import CheckObstacleCollision , is_valid

class Node:
    def __init__(self, n):
        self.x = n[0]
        self.y = n[1]
        self.parent = None


class IRrtStar:
    def __init__(self, map, x_start, x_goal, step_len,
                 goal_sample_rate, search_radius, iter_max):
      
        self.map= map
        self.x_start = Node(x_start)
        self.x_goal = Node(x_goal)
        self.step_len = step_len
        self.goal_sample_rate = goal_sample_rate
        self.search_radius = search_radius
        self.iter_max = iter_max
        self.fig, self.ax = plt.subplots()
        self.delta = 1
        self.x_range = (0,map.shape[0])
        self.y_range = (0,map.shape[1])
        self.edges =[]
        self.V = [self.x_start]
        self.X_soln = set()
        self.path = None

    def init(self):
        cMin, theta = self.get_distance_and_angle(self.x_start, self.x_goal)
        C = self.RotationToWorldFrame(self.x_start, self.x_goal, cMin)
        xCenter = np.array([[(self.x_start.x + self.x_goal.x) / 2.0],
                            [(self.x_start.y + self.x_goal.y) / 2.0], [0.0]])
        x_best = self.x_start

        return theta, cMin, xCenter, C, x_best

    def planning(self):
      print("I'll be rrunning for 1 and half min...")
      theta, dist, x_center, C, x_best = self.init()
      c_best = np.inf

      for k in range(self.iter_max):
          if self.X_soln:
              cost = {node: self.Cost(node) for node in self.X_soln}
              x_best = min(cost, key=cost.get)
              c_best = cost[x_best]

          x_rand = self.Sample(c_best, dist, x_center, C)
          if not is_valid((x_rand.x, x_rand.y),self.map):
            continue 
          x_nearest = self.Nearest(self.V, x_rand)
          x_new = self.Steer(x_nearest, x_rand)

          if x_new and not CheckObstacleCollision((x_nearest.x, x_nearest.y), (x_new.x, x_new.y), self.map) and  is_valid((x_nearest.x, x_nearest.y),self.map) and is_valid((x_new.x, x_new.y),self.map ):
              X_near = self.Near(self.V, x_new)
              c_min = self.Cost(x_nearest) + self.Line(x_nearest, x_new)
              self.V.append(x_new)
              for x_near in X_near:
                    c_new = self.Cost(x_near) + self.Line(x_near, x_new)
                    if c_new < c_min:
                        x_new.parent = x_near
                        c_min = c_new

              for x_near in X_near:
                    c_near = self.Cost(x_near)
                    c_new = self.Cost(x_new) + self.Line(x_new, x_near)
                    if c_new < c_near:
                        x_near.parent = x_new

              if self.InGoalRegion(x_new):
                  if not CheckObstacleCollision((x_new.x, x_new.y), (self.x_goal.x, self.x_goal.y), self.map):
                      self.X_soln.add(x_new)
              self.edges.append(((x_nearest.x, x_nearest.y), (x_new.x, x_new.y)))

      self.path = self.ExtractPath(x_best)
      plt.imshow(np.rot90(np.fliplr(self.map)), cmap='gray')  
      plt.title('Infomed_RRT*_20000 iteration_1.5 stepsize_1:48')
      plt.colorbar()
      path_x = [vertex[0] for vertex in self.path]
      path_y = [vertex[1] for vertex in self.path]
      plt.plot(path_x, path_y, color='red')
      plt.show()
      return path_x, path_y


    def Steer(self, x_start, x_goal):
        dist, theta = self.get_distance_and_angle(x_start, x_goal)
        dist = min(self.step_len, dist)
        node_new = Node((x_start.x + dist * math.cos(theta),
                         x_start.y + dist * math.sin(theta)))
        node_new.parent = x_start

        return node_new

    def Near(self, nodelist, node):
        n = len(nodelist) + 1
        r = 50 * math.sqrt((math.log(n) / n))

        dist_table = [(nd.x - node.x) ** 2 + (nd.y - node.y) ** 2 for nd in nodelist]
        X_near = [nodelist[ind] for ind in range(len(dist_table)) if dist_table[ind] <= r ** 2 and
                  not CheckObstacleCollision((nodelist[ind].x,nodelist[ind].y), (node.x,node.y), self.map)]

        return X_near

    def Sample(self, c_max, c_min, x_center, C):
        if c_max < np.inf:
            r = [c_max / 2.0,
                 math.sqrt(c_max ** 2 - c_min ** 2) / 2.0,
                 math.sqrt(c_max ** 2 - c_min ** 2) / 2.0]
            L = np.diag(r)

            while True:
                x_ball = self.SampleUnitBall()
                x_rand = np.dot(np.dot(C, L), x_ball) + x_center
                if self.x_range[0] + self.delta <= x_rand[0] <= self.x_range[1] - self.delta and \
                        self.y_range[0] + self.delta <= x_rand[1] <= self.y_range[1] - self.delta:
                    break
            x_rand = Node((x_rand[(0, 0)], x_rand[(1, 0)]))
        else:
            x_rand = self.SampleFreeSpace()

        return x_rand

    @staticmethod
    def SampleUnitBall():
        while True:
            x, y = random.uniform(-1, 1), random.uniform(-1, 1)
            if x ** 2 + y ** 2 < 1:
                return np.array([[x], [y], [0.0]])

    def SampleFreeSpace(self):
        delta = self.delta

        if np.random.random() > self.goal_sample_rate:
            return Node((np.random.uniform(self.x_range[0] + delta, self.x_range[1] - delta),
                         np.random.uniform(self.y_range[0] + delta, self.y_range[1] - delta)))

        return self.x_goal

    def ExtractPath(self, node):
        path = [[self.x_goal.x, self.x_goal.y]]

        while node.parent:
            path.append([node.x, node.y])
            node = node.parent

        path.append([self.x_start.x, self.x_start.y])

        return path

    def InGoalRegion(self, node):
        if self.Line(node, self.x_goal) < self.step_len:
            return True

        return False

    @staticmethod
    def RotationToWorldFrame(x_start, x_goal, L):
        a1 = np.array([[(x_goal.x - x_start.x) / L],
                       [(x_goal.y - x_start.y) / L], [0.0]])
        e1 = np.array([[1.0], [0.0], [0.0]])
        M = a1 @ e1.T
        U, _, V_T = np.linalg.svd(M, True, True)
        C = U @ np.diag([1.0, 1.0, np.linalg.det(U) * np.linalg.det(V_T.T)]) @ V_T

        return C

    @staticmethod
    def Nearest(nodelist, n):
        return nodelist[int(np.argmin([(nd.x - n.x) ** 2 + (nd.y - n.y) ** 2
                                       for nd in nodelist]))]

    @staticmethod
    def Line(x_start, x_goal):
        return math.hypot(x_goal.x - x_start.x, x_goal.y - x_start.y)

    def Cost(self, node):
        if node == self.x_start:
            return 0.0

        if node.parent is None:
            return np.inf

        cost = 0.0
        while node.parent:
            cost += math.hypot(node.x - node.parent.x, node.y - node.parent.y)
            node = node.parent

        return cost

    @staticmethod
    def get_distance_and_angle(node_start, node_end):
        dx = node_end.x - node_start.x
        dy = node_end.y - node_start.y
        return math.hypot(dx, dy), math.atan2(dy, dx)

def main():
    map_matrix = np.array(np.loadtxt("maps/np_map2_dilated.txt"))
    x_start = (140, 10)  # Starting node
    x_goal = (140, 50)  # Goal node
    map_matrix= np.array(map_matrix)
    step_len= 1
    goal_sample_rate=0.1
    search_radius=20
    iter_max=20000
    rrt_star = IRrtStar(map_matrix,x_start, x_goal, step_len, goal_sample_rate, search_radius, iter_max)
    path= rrt_star.planning()

if __name__ == '__main__':
    main()